:PROPERTIES:
:ID:       1fc7d65f-f629-4222-9c56-a00ed869d8b0
:END:
#+title: Fixed Point Functors
#+author: PureFunctor
#+filetags: :Article:Paper:PureScript:Todo:
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [letterpaper]
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \setlength{\parskip}{1em}
#+LATEX_HEADER: \setlength{\parindent}{0pt}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \lstset{breaklines=true,frame=single}

* Fixed-Point Functors
This article goes through the idea behind fixed-point [[id:fea2efbd-2a1b-44ea-853a-627feaaee3f0][functors]] and its applications inside of PureScript and functional
programming languages in general. I'll also be covering various other topics that deserve their own article but I'll be
discussing them just enough to synthesize it with the topic at hand.

** Recursion at the Term Level
*** Recursion
First, I'd like to talk about a purely practical overview of recursion as it's currently utilized in functional
languages such as PureScript.

Formally, recursion can be defined using two properties:
+ The base case
+ The recursive step

The *base case* refers to a scenario where recursion isn't used at all, while the *recursive step* refers to a scenario
where some computation must be performed in order to /reduce/ a repeated computation into a *base case*.

An easy example of recursion would be the ~factorial~ function. In PureScript, we can define it as such:

#+begin_src purescript -n
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
#+end_src

The base case for our ~factorial~ function states that for zero, the output is one, while the recursive step states that
for all integers ~n~ that is not zero, its factorial is equal to ~n~ multiplied to the factorial of ~n - 1~.

To further enhance one's intuition on recursion, we can visualize the internal call tree that is built when evaluating
~factorial 5~.

#+begin_src purescript -n
factorial 5 = 5 * factorial 4
factorial 4 = 4 * factorial 3
factorial 3 = 3 * factorial 2
factorial 2 = 2 * factorial 1
factorial 1 = 1 * factorial 0
factorial 0 = 1
#+end_src

If we follow the trail of breadcrumbs, we eventually end up with:

#+begin_src purescript -n
factorial 5 = 5 * (4 * (3 * (2 * (1 * 1))))
#+end_src

Notice that I've deliberately wrapped around the terms in parentheses and that I haven't evaluated them
immediately. This is because a recursive function such as ~factorial~ often builds up deep call trees essentially have to
be evaluated only once the entire structure is built. This often manifests as a performance problem such as running out
of stack space.

*** Recursion in a Lambda
Recursion in languages that allow declarations is quite easy: it only involves the programmer encoding the base case and
the recursive step and binding them into a name that can be referred to in the recursive step or even later in the
program.

#+begin_src purescript -n
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
#+end_src

However, if we want to constrain ourselves exclusively to lambda calculus, we'd have to find some workarounds. In a
lambda calculus, let bindings can be represented as immediately-invoked functions:

#+begin_src purescript -n
let x = 1 + 1
 in x + 1
#+end_src

can be encoded as

#+begin_src purescript -n
(\x -> x + 1)(1 + 1)
#+end_src

This works well for an indeterminate number of terms that are not recursive, but it easily falls apart for recursive
functions.

#+begin_src purescript -n
(\factorial -> factorial 5)(\n -> if n == 0 then 1 else n * ?factorial (n - 1))
#+end_src

Let's think about this for a moment, if we're unable to access a binding that refers to factorial, what else do we do?
Consider the following: functional purity implies referential transparency. This means that we can substitute the call
to a function with its result and we'd have the same program.

What if we make the factorial function accept another function, with that other function being itself?

#+begin_src purescript -n
(\f n -> if n == 0 then 1 else n * f f (n - 1))
#+end_src

After doing so, all that's left is the integer ~n~ that we want to call factorial on.

#+begin_src purescript -n
(\f n -> if n == 0 then 1 else n * f f (n - 1))(\f n -> if n == 0 then 1 else n * f f (n - 1))
#+end_src

As straightforward as this seems, PureScript's type-checker won't accept such definition as it creates an infinite
type. Since we're talking in terms of untyped lambda calculus however, one can easily evaluate this by hand and end up
with a proper factorial function.

Like all things in mathematics, this pattern can be generalized into a more reusable form. The /Y combinator/ is an
example of such generalization. Consider the following definition:

#+begin_src purescript -n
y = \f -> (\x -> f (x x)) (\x -> f (x x))
#+end_src

While I can discuss the /Y combinator/ in-depth in this article, I also feel like it'll take too much time if I
did; I suggest watching [[https://www.youtube.com/watch?v=9T8A89jgeTI][this Computerphile video on the Y combinator]] instead.

A more workable definition of this pattern would be the fixed-point combinator, which is formally defined as the
following. Unfortunately, this definition alone will not work in PureScript as its strict nature would cause ~fix~ to
recurse forever until the stack is exhausted.

#+begin_src purescript -n
fix :: forall a. (a -> a) -> a
fix f = f (fix f)
#+end_src

*** Recursion using the Fixed-Point Combinator

In order to avoid invoking the [[https://twitter.com/bos31337/status/116372971509121025][wrath of the type checker]] and exhausting the stack, we have to perform some indirection.
PureScript defines the fixed-point combinator in the [[https://pursuit.purescript.org/packages/purescript-control/5.0.0/docs/Control.Lazy#v:fix][Control.Lazy]] module as the following:

#+begin_src purescript -n
fix :: forall l. Lazy l => (l -> l) -> l
fix f = go
  where
    go = defer \_ -> f go
#+end_src

The ~Lazy~ type class and its ~defer~ method allows us to "thunk" the result of the recursion until we actually need
it. When we apply ~fix~ to with anonymous factorial, we get the desired result.

#+begin_src purescript -n
> fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 5
120
#+end_src
