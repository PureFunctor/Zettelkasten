:PROPERTIES:
:ID:       c4317425-5316-486f-8b79-70df22ea5dcd
:END:
#+title: Coercible
#+filetags: :PureScript:

* Coercible
The ~Coercible~ [[id:479ebd3d-f89d-45b3-894b-494905524c2f][type class]] is a compiler-implemented type class in
PureScript that relates two types based on whether they have the same
representation at runtime.

#+begin_src purescript
class Coercible (a :: k) (b :: k)
#+end_src

** Laws
The ~Coercible~ type class solves constraints between types based on the
following laws:

*** Reflexivity
Any type has the same representation as itself i.e. ~Coercible a a~

*** Symmetry
If some type ~a~ can be coerced into some other type ~b~, then ~b~ can be coerced
back into an ~a~.

*** Transitivity
If some type ~a~ can be coerced into some type ~b~, and ~b~ can be coerced
into some other type ~c~, then ~a~ can be coerced into ~c~.

** Newtypes are Coercible
:PROPERTIES:
:ID:       e2466932-a004-483c-b07d-9c40a1d79234
:END:
[[id:a603d7e4-d9a5-4d0f-a7a3-13c939200c2a][Newtypes]] are designed to hold the same runtime representation as the
type that it wraps around. As such, PureScript allows newtypes to be
freely coerced into and from the type being wrapped, _as long as the
newtype constructor also exists in the scope_.

In general, newtypes serve as the primary target for safe coercions in
day-to-day programming.

Likewise, ~Coercible~, in conjuction with [[id:0b88319b-63f7-49c1-930a-76111044bc95][newtypes for extending behaviour]]
allows for the implementation of [[https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/deriving_via.html][DerivingVia]].

** Coercible Tricks
:PROPERTIES:
:ID:       9bef7e0f-8f3e-45be-bde7-558f8cea6da9
:END:
The following section is a few tricks that I've learned from writing
code that makes use of [[id:a603d7e4-d9a5-4d0f-a7a3-13c939200c2a][newtypes]].

*** Coercing the Function Arrow

Instead of explicitly wrapping and unwrapping newtypes, we can simply
use ~coerce~!

#+begin_src purescript
newtype Identity a = Identity a

plusOne :: Int -> Int
plusOne x = x + 1

plusOneI :: Identity Int -> Identity Int
plusOneI = coerce plusOne
#+end_src

*** Coercing Type Variables

~Coercible~, while being powerful, is also conservative when it comes to
actually coercing types. As such, we'd have to help it by explicitly
providing constraints to type variables like so.

#+begin_src purescript
newtype Identity a = Identity a

coerceM
  :: forall m a b
  .  Monad m
  => Coercible (m Int) (m (Identity Int))
  => (Int          -> m Int           )
  -> (Identity Int -> m (Identity Int))
#+end_src

In this example, I'm telling ~Coercible~ that the [[id:72cf5e6f-b268-40b7-87de-edddf2fa26f1][monad]] ~m~ being passed
must be coercible. Since ~Int~ is coercible to ~Identity Int~, and ~m~ is the
same type on both sides, we're able to define this coercion just fine.
