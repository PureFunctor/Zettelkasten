:PROPERTIES:
:ID:       479ebd3d-f89d-45b3-894b-494905524c2f
:END:
#+title: Type Classes
#+filetags: :PureScript:

* Type Classes
Generally, there are multiple interpretations of what type classes are
supposed to be in PureScript.

Oftentimes, they're typically used to model [[id:643fdefc-ce22-41ec-90ee-6229c09fc6a2][polymorphism]], allowing one
to assert that some type implements a specific type class' methods. In
certain instances, these implementations must also follow specific laws
in order to be a "lawful instance".

On the other hand, type classes in PureScript are used to model
relationships between types, often substituing for type-level functions
commonly found in languages with dependent types such as Idris, or to a
certain degree, Haskell.

This use case is achieved through PureScript's intrinsic support for
[[id:edecce70-6703-4b65-8aa0-c92bcdb02bd0][multiple parameters]], as well as [[id:e8f73786-4d16-4310-b615-14cb0d7bde1c][functional dependencies]] in type classes.

** Multiple Parameters
:PROPERTIES:
:ID:       edecce70-6703-4b65-8aa0-c92bcdb02bd0
:END:

Unlike Haskell[fn:1], PureScript supports multiple type parameters in
type class definitions without the need of a compiler definition. It
allows one to define a type class as follows:

#+begin_src purescript
class MeAndYou me you where
  pointTo :: me -> you
#+end_src

** Functional Dependencies
:PROPERTIES:
:ID:       e8f73786-4d16-4310-b615-14cb0d7bde1c
:END:

Functional dependencies further enrich type classes by allowing one to
explicitly state the relationship between multiple type class
parameters.

For a better intuition, here's an example:

#+begin_src purescript
class MeAndYou me you | me -> you where
  pointTo :: me -> you
#+end_src

The added vertical bar (~|~) and arrow-function-like syntax (~me -> you~)
expresses that for some type ~me~, there exists a matching
~you~. Essentially, what this means is that for every ~MeAndYou~ instance,
only a single ~you~ maps to some ~me~:

#+begin_src purescript
instance MeAndYou Me You      -- Yes!
instance MeAndYou Me Someone  -- No!
#+end_src

However, some other ~me~ can also instantiate against ~You~:

#+begin_src purescript
instance MeAndYou MeAgain You  -- Yes!
#+end_src

We can add another functional dependency: (~you -> me~) to determine that
for every ~me~, there exists a specific ~you~ and vice versa.

#+begin_src purescript
class MeAndYou me you | me -> you, you -> me where
  pointTo :: me -> you

instance MeAndYou MeOnly YouOnly   -- Yes!
instance MeAndYou MeOnly Someone   -- No!
instance MeAndYou Someone YouOnly  -- No!
#+end_src

** Type-Level Programming

Perhaps the most unorthodox use of type classes in PureScript is
type-level programming. Multiple parameters in type classes, in
conjuction with functional dependencies allow one to write
"relationships" between types.

Likewise, PureScript's types and [[id:22a65600-2728-40c5-a4bc-ea8743ebed64][kinds]] allow [[id:d0079b91-cea6-4adf-8fc0-98ce39f5d5f2][pattern matching]] even at
the type-level! This completes the triad of features needed to implement
"type functions".

For a more in-depth look at type-level programming, see the following
article node: [[id:e8500976-ee0b-4b7f-9974-2321498ff6c1][Type-Level Programming using Type Classes]]

* Footnotes

[fn:1] Haskell2021 enables the ~MultiParamTypeClasses~ extension by
default, but as far as I know, most compilers still default to
Haskell2010
